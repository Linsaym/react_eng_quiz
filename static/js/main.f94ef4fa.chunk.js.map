{"version":3,"sources":["App.styles.ts","atoms/Avatar/Avatar.styles.ts","atoms/Avatar/Avatar.tsx","atoms/Button/Button.styles.ts","atoms/Button/Button.tsx","atoms/SentenceWord/SentenceWord.styles.ts","atoms/SentenceWord/SentenceWord.tsx","atoms/Title/Title.styles.ts","atoms/Title/Title.tsx","molecules/Sentence/Sentence.styles.ts","molecules/Sentence/Sentence.tsx","settings/constants.ts","locales.ts","pages/Quiz/Quiz.helpers.ts","atoms/Message/Message.styles.ts","atoms/Message/Message.tsx","atoms/AnswerWord/AnswerWord.styles.ts","atoms/AnswerWord/AnswerWord.tsx","libs/Draggable/Draggable.tsx","atoms/Anchor/Anchor.styles.ts","atoms/Anchor/Anchor.tsx","molecules/DropArea/DropArea.styles.ts","molecules/DropArea/DropArea.tsx","pages/Quiz/Quiz.styles.ts","pages/Quiz/Quiz.tsx","App.tsx","reportWebVitals.ts","settings/fonts/Roboto/Roboto-Regular.woff","settings/fonts/fonts.ts","index.tsx"],"names":["StyledApp","styled","div","StyledAvatar","DefaultAvatar","Avatar","src","alt","StyledButton","button","props","isMove","Button","content","onclickHandler","onClick","StyledSentenceWord","span","SentenceWord","React","memo","StyledTitle","h1","Title","StyledSentence","SentenceTip","SentenceList","ul","Sentence","children","TRANSITION_TIME","INITIAL_TRANSLATE_COORDS","x","y","INITIAL_SHIFT_COORDS","shiftX","shiftY","initialX","initialY","INITIAL_DRAGGABLE_ID","originId","wordId","locales","language","messages","q1","question","answers","correct","getCorrectAnchors","target","quizId","Translator","translate","split","map","_","index","anchorId","isHidden","answerId","isPrepared","getQuestionText","getMessageById","getConvertedAnchors","anchors","Array","isArray","reduce","acc","anchor","Object","values","getConvertedWords","words","word","getAnchorsDomList","anchorsDomRoot","from","length","matches","calcOriginCoords","root","idBeforeDraggableElem","settings","direction","coords","getAnchorsDomCoords","originCoords","id","getBoundingClientRect","getIdBeforeDraggableElem","draggableElem","action","wordsList","wordsArea","isGap","shiftedId","isBlocked","find","filter","getUpdatedAnswersAnchors","targetAnchor","convertedAnchors","reverse","getShiftedWords","dragId","elementAction","directionShift","includes","StyledMessage","isShow","MessageText","isError","Message","StyledAnswerWord","AnswerWord","style","onMouseDown","className","onTouchStart","Draggable","draggableElemInfo","isTransitioned","dragStartHandler","dragMoveHandler","dragEndHandler","isBlockAnimaton","useState","isDragStart","setDragStart","inDropArea","useRef","currentArea","prevDropArea","debounce","translateCoords","setTranslateCoords","shiftCoords","setShiftCoords","getBellowElemDataAttr","bellowElem","keys","dataset","dropname","setCurrentArea","useCallback","dropAreaName","current","isDraggableElemInDropArea","getBellowElement","visibility","selector","elem","s","document","elementFromPoint","closest","defineElemFromPoint","dragStart","ev","nativeEvent","MouseEvent","clientX","clientY","prevState","ondragstart","dragMove","TouchEvent","touches","touchShifteCoords","preventDefault","currentAreaName","dragEnd","changedTouches","bellowElement","Number","useEffect","window","addEventListener","removeEventListener","useMemo","willChange","transform","transition","zIndex","position","background","Children","item","cloneElement","StyledAnchor","li","Anchor","isDataAttr","data-anchor","data-id","StyledDropArea","Wrapper","DropArea","forwardRef","ref","areaName","preparedWords","createWord","isDataAttribute","text","data-dropname","Math","ceil","row","slice","anchorWrapper","rowId","StyledQuiz","QuizInfo","QuizAnswersWrapper","QuizWaitingWrapper","QuizButtonWrapper","Quiz","resultMessage","setResultMessage","setError","setBlockAnimation","dragEndEvent","setDragEndEvent","waitingRef","answersRef","draggableId","setDraggableId","waitingOriginCoords","setWaitingOriginCoords","answersOriginCoords","setAnswersOriginCoords","getCorrectWords","waitingWords","setWaitingWords","answersWords","setAnswersWords","answersAnchors","setAnswersAnchors","getNewOriginCoords","prevOriginCoords","calculatedOriginCoords","getAnswerPreparedAnchor","getEmptyAnswerAnchor","resetOriginCoords","time","setTimeout","translateDragElemFromPending","params","targetAnchorCoords","draggableElemCoords","translateDragElemFromAnswers","anchorsRoot","translateWaitingWords","checkAnswerHandler","correctText","getCorrectText","answersText","join","localeCompare","correctCurrentArea","isTargetWaitingAnchorBusy","targetWord","shiftedwaitingWords","convertedWords","idBeforeAnswers","shiftedAnswersWords","shiftedAnswerWords","push","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","createGlobalStyle","normalize","RobotoURLwoff","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.f94ef4fa.chunk.js","sourcesContent":["import styled from 'styled-components';\n\nconst StyledApp = styled.div`\n  padding: 0 20px;\n`;\n\nexport default StyledApp;\n","import styled from 'styled-components';\n\nconst StyledAvatar = styled.div`\n  padding: 0px 40px;\n  padding-bottom: 79px;\n`;\n\nconst DefaultAvatar = styled.div`\n  position: relative;\n  width: 114px;\n  height: 114px;\n  border-radius: 10em;\n  background: #6c6c6c;\n  &::after {\n    content: '';\n    position: absolute;\n    width: 185.65px;\n    height: 93.5px;\n    top: 100px;\n    left: -35px;\n    border-bottom-right-radius: 10px;\n    border-bottom-left-radius: 10px;\n    border-top-left-radius: 5em;\n    border-top-right-radius: 5em;\n    background: #6c6c6c;\n  }\n`;\n\nexport { StyledAvatar, DefaultAvatar };\n","import React from 'react';\nimport { IAvatarProps } from './Avatar.types';\nimport { DefaultAvatar, StyledAvatar } from './Avatar.styles';\nconst Avatar = ({ src }: IAvatarProps) => {\n  return <StyledAvatar>{src ? <img src={src} alt=\"avatar\" /> : <DefaultAvatar />}</StyledAvatar>;\n};\n\nexport default Avatar;\n","import styled from 'styled-components';\nimport { IStyledButtonProps } from './Button.types';\n\nconst StyledButton = styled.button<IStyledButtonProps>`\n  width: 100%;\n  height: 50px;\n  border: none;\n  border-radius: 88px;\n  background: linear-gradient(91.2deg, #ffffff 0%, #f2f2f2 100%);\n  box-shadow: -2px -4px 12px #ffffff, 2px 4px 8px rgba(0, 0, 0, 0.2);\n  will-change: transform;\n  transition: transform 500ms ease;\n\n  font: bold normal 18px/21px Roboto, sans-serif;\n  text-align: center;\n  cursor: pointer;\n\n  &:hover {\n    background: linear-gradient(54deg, #f8f8f8 0%, #eae9e9 100%);\n  }\n\n  &:focus {\n    outline: none;\n    border: 1px solid #9e9e9e;\n  }\n\n  &:active {\n    background: linear-gradient(91.2deg, #ffffff 0%, #f2f2f2 100%);\n    box-shadow: inset -2px -4px 12px #ffffff, inset 2px 4px 8px rgba(0, 0, 0, 0.2);\n    border: none;\n  }\n\n  transform: ${props => props.isMove && 'translateY(60px)'};\n`;\n\nexport default StyledButton;\n","import React from 'react';\nimport StyledButton from './Button.styles';\nimport { IButtonProps } from './Button.types';\n\nconst Button = ({ content, onclickHandler, isMove }: IButtonProps) => {\n  return (\n    <StyledButton onClick={onclickHandler} isMove={isMove}>\n      {content}\n    </StyledButton>\n  );\n};\n\nexport default Button;\n","import styled from 'styled-components';\n\nconst StyledSentenceWord = styled.span`\n  font: normal normal 18px/21px Roboto, sans-serif;\n  border-bottom: 1px dashed #000000;\n  cursor: help;\n`;\n\nexport default StyledSentenceWord;\n","import React from 'react';\nimport { ISentenceWordProps } from './SentenceWord.types';\nimport StyledSentenceWord from './SentenceWord.styles';\nconst SentenceWord = ({ content }: ISentenceWordProps) => {\n  return <StyledSentenceWord>{content}</StyledSentenceWord>;\n};\n\nexport default React.memo(SentenceWord);\n","import styled from 'styled-components';\n\nconst StyledTitle = styled.h1`\n  font: normal normal 36px/42px Roboto, sans-serif;\n  color: #252525;\n  text-shadow: -2px -4px 3px #ffffff, 2px 4px 3px rgba(0, 0, 0, 0.25);\n`;\nexport default StyledTitle;\n","import { ITitleProps } from './Title.types';\nimport StyledTitle from './Title.styles';\n\nconst Title = ({ content }: ITitleProps) => {\n  return <StyledTitle>{content}</StyledTitle>;\n};\n\nexport default Title;\n","import styled from 'styled-components';\n\nconst StyledSentence = styled.div`\n  position: relative;\n  max-width: 200px;\n  max-height: 69px;\n  padding: 12px;\n  border: 2px solid #252525;\n  border-radius: 10px;\n`;\nconst SentenceTip = styled.span`\n  display: inline-block;\n  position: absolute;\n  width: 7px;\n  height: 15px;\n  top: 60%;\n  left: -7px;\n  background: white;\n  &::after {\n    content: '';\n    position: absolute;\n    width: 20.7px;\n    height: 1.5px;\n    top: 6.5px;\n    left: -11px;\n    border-radius: 17px;\n    background: black;\n    transform: rotate(133deg);\n  }\n\n  &::before {\n    content: '';\n    position: absolute;\n    height: 1.4px;\n    width: 15px;\n    top: 14px;\n    right: 0.1px;\n    border-radius: 20px;\n    background: black;\n  }\n`;\nconst SentenceList = styled.ul`\n  display: flex;\n  flex-flow: row wrap;\n  gap: 7px;\n  max-height: 70px;\n  margin: 0;\n  padding: 2px;\n  list-style-type: none;\n  overflow: auto;\n`;\n\nexport { SentenceList, SentenceTip, StyledSentence };\n","import React from 'react';\nimport { SentenceList, SentenceTip, StyledSentence } from './Sentence.styles';\nimport { SentencePropsType } from './Sentence.types';\n\nconst Sentence = ({ children }: SentencePropsType) => {\n  return (\n    <StyledSentence>\n      <SentenceTip />\n      <SentenceList>{children}</SentenceList>\n    </StyledSentence>\n  );\n};\n\nexport default Sentence;\n","const TRANSITION_TIME = 500;\nconst INITIAL_TRANSLATE_COORDS = { x: 0, y: 0 };\nconst INITIAL_SHIFT_COORDS = {\n  shiftX: 0,\n  shiftY: 0,\n  initialX: 0,\n  initialY: 0,\n};\nconst INITIAL_DRAGGABLE_ID = {\n  originId: 0,\n  wordId: 0,\n};\nexport { TRANSITION_TIME, INITIAL_SHIFT_COORDS, INITIAL_TRANSLATE_COORDS, INITIAL_DRAGGABLE_ID };\n","const locales = [\n  {\n    language: 'en', // words to translate\n    messages: {\n      q1: {\n        question: 'his name is jack and he is a pilot',\n      },\n    },\n  },\n\n  {\n    language: 'ru', // answers words\n    messages: {\n      q1: {\n        answers: 'пилот его и Джек он имя',\n        correct: 'его имя Джек и он пилот',\n      },\n    },\n  },\n];\n\nexport default locales;\n","import { IAnchor } from '../../atoms/Anchor/Anchor.types';\nimport { IWord } from '../../atoms/AnswerWord/AnswerWord.types';\nimport { IOriginCoords } from './Quiz.types';\nimport { Translator } from '@eo-locale/core';\nimport locales from '../../locales';\n\nconst getCorrectWords = (language: 'ru' | 'en', target: 'answers' | 'correct', quizId: string): IWord[] => {\n  const words = new Translator(language, locales).translate(`${quizId}.${target}`);\n  return words.split(' ').map((text, index) => ({\n    text,\n    wordId: index,\n    originId: index,\n    from: 'waiting',\n  }));\n};\n\nconst getCorrectAnchors = (language: 'ru' | 'en', target: 'answers' | 'correct', quizId: string): IAnchor[] => {\n  const words = new Translator(language, locales).translate(`${quizId}.${target}`);\n  return words.split(' ').map((_, index) => ({\n    anchorId: index,\n    isHidden: target === 'answers',\n    answerId: null,\n    isPrepared: false,\n  }));\n};\n\nconst getCorrectText = (quizId: string) => {\n  return new Translator('ru', locales).getMessageById(`${quizId}.correct`) as string;\n};\n\nconst getQuestionText = (quizId: string) => {\n  return new Translator('en', locales).getMessageById(`${quizId}.question`) as string;\n};\n\nconst getConvertedAnchors = <R extends IAnchor[] | { [key: string]: IAnchor }>(\n  anchors: R\n): R extends IAnchor[] ? { [key: string]: IAnchor } : IAnchor[] =>\n  Array.isArray(anchors)\n    ? anchors.reduce((acc, anchor) => ({ ...acc, [anchor.anchorId]: { ...anchor } }), {})\n    : Object.values(anchors);\n\nconst getConvertedWords = (words: IWord[]): { [key: string]: IWord } =>\n  words.reduce((acc, word) => ({ ...acc, [word.wordId]: { ...word } }), {});\n\nconst getAnchorsDomList = <T extends HTMLElement>(anchorsDomRoot: T): T[] =>\n  (Array.from(anchorsDomRoot.children) as T[]).reduce(\n    (anchors: T[], anchor) =>\n      anchor.children.length !== 0 && !anchor.children[0].matches('.answer-word')\n        ? [...anchors, ...getAnchorsDomList(anchor)]\n        : [...anchors, anchor],\n    []\n  );\n\nconst calcOriginCoords = (\n  root: HTMLElement,\n  idBeforeDraggableElem: number[],\n  settings?: { direction: 'right' | 'left' }\n) => {\n  const { direction } = settings ?? { direction: 'left' }; //default settings\n  const coords = getAnchorsDomCoords(root);\n  return idBeforeDraggableElem.reduce(\n    (originCoords: IOriginCoords, id) => ({\n      ...originCoords,\n      [id]: {\n        x: coords[direction === 'right' ? (coords.length === id + 1 ? id : id + 1) : id - 1].x - coords[id].x, // overfloow\n        y: coords[direction === 'right' ? (coords.length === id + 1 ? id : id + 1) : id - 1].y - coords[id].y, // overfloow\n      },\n    }),\n    {}\n  );\n};\n\nconst getAnchorsDomCoords = (anchorsDomRoot: HTMLElement) =>\n  getAnchorsDomList(anchorsDomRoot).map(anchor => ({\n    x: anchor.getBoundingClientRect().x,\n    y: anchor.getBoundingClientRect().y,\n  }));\n\nconst getIdBeforeDraggableElem = (\n  words: { wordsList: IWord[]; wordsArea: 'waiting' | 'answers' },\n  draggableElem: IWord,\n  action: 'put' | 'take'\n) => {\n  const { wordsList, wordsArea } = words;\n  const isGap = (word: IWord) => {\n    if (word.wordId - shiftedId > 1) {\n      isBlocked = true;\n      return false;\n    } else {\n      shiftedId += 1;\n      return true;\n    }\n  };\n\n  const isAnchorBusy =\n    draggableElem.from === 'waiting' ? true : wordsList.find(word => word.wordId === draggableElem.originId);\n  let isBlocked = isAnchorBusy ? false : true;\n  let shiftedId = action === 'put' ? draggableElem.originId : draggableElem.wordId;\n  const result = wordsList\n    .filter(word => {\n      if (wordsArea === 'waiting') {\n        if (isBlocked) return false;\n        if (action === 'put') {\n          if (word.wordId >= draggableElem.originId) {\n            return isGap(word);\n          } else {\n            return false;\n          }\n        } else {\n          if (word.wordId > draggableElem.wordId) {\n            return isGap(word);\n          } else {\n            return false;\n          }\n        }\n      } else {\n        return word.wordId > draggableElem.wordId;\n      }\n    })\n    .map(word => word.wordId);\n  return result;\n};\n\nconst getUpdatedAnswersAnchors = (\n  anchors: IAnchor[],\n  action: 'setBusy' | 'delBusy' | 'prepare' | 'disprepare' | 'prepareLast'\n) => {\n  const convertedAnchors = getConvertedAnchors(anchors);\n  let targetAnchor;\n  switch (action) {\n    case 'setBusy': {\n      targetAnchor = [...anchors].reverse().find(anchor => anchor.isPrepared);\n      break;\n    }\n    case 'delBusy': {\n      targetAnchor = [...anchors].reverse().find(anchor => anchor.answerId !== null);\n      break;\n    }\n    case 'disprepare': {\n      targetAnchor = [...anchors].reverse().find(anchor => anchor.isPrepared && anchor.answerId === null);\n      break;\n    }\n    case 'prepareLast': {\n      targetAnchor = [...anchors].reverse().find(anchor => anchor.answerId !== null) as IAnchor;\n      break;\n    }\n    default: {\n      targetAnchor = anchors.find(anchor => anchor.answerId === null);\n      break;\n    }\n  }\n\n  // check undefined\n  if (targetAnchor) {\n    convertedAnchors[targetAnchor.anchorId] = {\n      ...targetAnchor,\n      isPrepared: action === 'prepare' || action === 'prepareLast',\n      answerId: action === 'setBusy' || action === 'prepareLast' ? targetAnchor.anchorId : null,\n    };\n  }\n\n  return getConvertedAnchors(convertedAnchors);\n};\n\nconst getShiftedWords = (\n  words: IWord[],\n  dragId: number,\n  idBeforeDraggableElem: number[],\n  settings: { elementAction: 'remove' | 'add'; directionShift: 'left' | 'right' }\n) => {\n  const { elementAction, directionShift } = settings;\n\n  const correctWords = elementAction === 'add' ? words : words.filter(word => word.wordId !== dragId);\n  return correctWords.map(word =>\n    idBeforeDraggableElem.includes(word.wordId)\n      ? {\n          ...word,\n          wordId:\n            directionShift === 'right'\n              ? words.length === word.wordId // overfloow\n                ? word.wordId\n                : word.wordId + 1\n              : word.wordId - 1,\n        }\n      : word\n  );\n};\n\nexport {\n  calcOriginCoords,\n  getAnchorsDomCoords,\n  getIdBeforeDraggableElem,\n  getShiftedWords,\n  getUpdatedAnswersAnchors,\n  getConvertedWords,\n  getAnchorsDomList,\n  getConvertedAnchors,\n  getCorrectWords,\n  getCorrectAnchors,\n  getCorrectText,\n  getQuestionText,\n};\n","import styled from 'styled-components';\nimport { IMessageTextProps, IStyledMessagepProps } from './Message.types';\nconst errorColor = '#ff0000';\nconst successColor = 'rgb(133, 238, 203)';\n\nconst StyledMessage = styled.div<IStyledMessagepProps>`\n  position: relative;\n  will-change: opacity;\n  opacity: ${props => (props.isShow ? 1 : 0)};\n  transition: opacity 2000ms ease;\n  width: 50%;\n`;\n\nconst MessageText = styled.span<IMessageTextProps>`\n  position: absolute;\n  left: 0;\n  right: 0;\n  position: absolute;\n  text-align: center;\n  font: normal normal 24px/28px Roboto, sans-serif;\n  color: ${props => (props.isError ? errorColor : successColor)};\n  text-shadow: -1px -2px 2px #ffffff, 1px 2px 2px rgba(91, 13, 13, 0.5);\n`;\n\nexport { StyledMessage, MessageText };\n","import React from 'react';\nimport { MessageText, StyledMessage } from './Message.styles';\nimport { IMessageProps } from './Message.types';\n\nconst Message = ({ content, isError }: IMessageProps) => {\n  const isShow = content ? true : false;\n  return (\n    <StyledMessage isShow={isShow}>\n      <MessageText isError={isError}>{content}</MessageText>\n    </StyledMessage>\n  );\n};\n\nexport default Message;\n","import styled from 'styled-components';\n\nconst StyledAnswerWord = styled.span`\n  width: 70px;\n  height: 30px;\n  background: #ffffff;\n  border: 1px solid #c9c9c9;\n  box-shadow: 0px 8px 4px -6px rgba(0, 0, 0, 0.25);\n  border-radius: 13px;\n  display: inline-block;\n  will-change: transform;\n  touch-action: none;\n\n  font: normal normal 16px/25px Roboto;\n  color: #000000;\n  text-align: center;\n  user-select: none;\n  cursor: grab;\n  &:active {\n    cursor: grabbing;\n  }\n`;\n\nexport { StyledAnswerWord };\n","import React from 'react';\nimport { StyledAnswerWord } from './AnswerWord.styles';\nimport { IAnswerWordProps } from './AnswerWord.types';\nconst AnswerWord = ({ content, style, onMouseDown }: IAnswerWordProps) => {\n  return (\n    <StyledAnswerWord\n      style={style}\n      className={'answer-word'}\n      onMouseDown={onMouseDown ?? null}\n      onTouchStart={onMouseDown ?? null}\n    >\n      {content}\n    </StyledAnswerWord>\n  );\n};\n\nexport default AnswerWord;\n","import React, { Fragment, useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { INITIAL_SHIFT_COORDS, INITIAL_TRANSLATE_COORDS, TRANSITION_TIME } from '../../settings/constants';\nimport { DraggablePropsType, GetBellowElement } from './Draggable.types';\n\nconst Draggable = ({\n  draggableElemInfo,\n  children,\n  isTransitioned,\n  originCoords,\n  dragStartHandler,\n  dragMoveHandler,\n  dragEndHandler,\n  isBlockAnimaton,\n}: DraggablePropsType) => {\n  // ANIMATION CONTROL------------------------------------------------------------\n  const [isDragStart, setDragStart] = useState(false);\n\n  // SETTINGS FOR DETERMINING THE CURRENT ZONE (bellow element)-------------------\n  const inDropArea = useRef(false);\n  const currentArea = useRef(draggableElemInfo.from === 'waiting' ? 'waitingArea' : 'answersArea');\n  const prevDropArea = useRef(draggableElemInfo.from === 'waiting' ? 'waitingArea' : 'answersArea');\n  const debounce = useRef<string | null>(null);\n\n  // TRANSLATE COORDS-------------------------------------------------------------\n  const [translateCoords, setTranslateCoords] = useState(INITIAL_TRANSLATE_COORDS);\n  const [shiftCoords, setShiftCoords] = useState(INITIAL_SHIFT_COORDS);\n\n  // HELPERS FUNCTIONS---------------------------------------------------\n  const getBellowElemDataAttr = (bellowElem: HTMLElement | null) => {\n    if (bellowElem) {\n      return Object.keys(bellowElem.dataset).length !== 0\n        ? bellowElem.dataset.dropname\n          ? (bellowElem.dataset.dropname as string)\n          : (bellowElem.dataset.anchor as string)\n        : null;\n    } else {\n      return null;\n    }\n  };\n\n  const defineElemFromPoint = (selector: string | string[], coords: [x: number, y: number]) =>\n    Array.isArray(selector)\n      ? selector.reduce(\n          (elem: HTMLElement | null, s) =>\n            elem === null && document.elementFromPoint(...coords) !== null\n              ? (document.elementFromPoint(...coords) as HTMLElement).closest(s)\n                ? (document.elementFromPoint(...coords) as HTMLElement).closest(s)\n                : elem\n              : elem,\n          null\n        )\n      : ((document.elementFromPoint(...coords) as HTMLElement).closest(selector) as HTMLElement);\n\n  const setCurrentArea = useCallback((dropAreaName: string | null) => {\n    if (inDropArea.current && dropAreaName) {\n      if (prevDropArea.current === dropAreaName) {\n        return dropAreaName;\n      } else {\n        prevDropArea.current = dropAreaName;\n        return dropAreaName;\n      }\n    } else {\n      return `out-${prevDropArea.current}`;\n    }\n  }, []);\n\n  const isDraggableElemInDropArea = useCallback(\n    (bellowElem: null | HTMLElement) =>\n      // если курсор выходит за viewport, то bellowElem = null\n      bellowElem\n        ? bellowElem.dataset.dropname || bellowElem.matches('[data-anchor=\"waitingAnchor\"]')\n          ? true\n          : false\n        : false,\n    []\n  );\n\n  const getBellowElement: GetBellowElement = useCallback((target, x, y) => {\n    const matchList = ['[data-anchor=\"waitingAnchor\"]', '[data-dropname]'];\n\n    target.style.visibility = 'hidden';\n    const bellowElem = defineElemFromPoint(matchList, [x, y]);\n    target.style.visibility = '';\n\n    return bellowElem ?? (document.elementFromPoint(x, y) as HTMLElement);\n  }, []);\n\n  const makeDraggableElement = () =>\n    React.Children.map(children, item => {\n      return React.cloneElement(item, {\n        ...item.props,\n        style,\n        onMouseDown: isBlockAnimaton ? null : dragStart,\n        onTouchStart: isBlockAnimaton ? null : dragStart,\n      });\n    });\n\n  // HANDLER FUNCTIONS---------------------------------------------------\n  const dragStart = useCallback(\n    (ev: React.MouseEvent<HTMLSpanElement> | React.TouchEvent<HTMLSpanElement>) => {\n      let shiftCoords =\n        ev.nativeEvent instanceof MouseEvent\n          ? [(ev as React.MouseEvent).clientX, (ev as React.MouseEvent).clientY]\n          : [0, 0];\n\n      const draggableElem = ev.target as HTMLSpanElement;\n      setDragStart(true);\n\n      setShiftCoords(prevState => ({\n        ...prevState,\n        shiftX: shiftCoords[0] - draggableElem.getBoundingClientRect().x,\n        shiftY: shiftCoords[1] - draggableElem.getBoundingClientRect().y,\n        initialX: draggableElem.getBoundingClientRect().x,\n        initialY: draggableElem.getBoundingClientRect().y,\n      }));\n\n      dragStartHandler({\n        from: draggableElemInfo.from,\n        dragId: draggableElemInfo.wordId,\n      });\n      draggableElem.ondragstart = () => false;\n    },\n    [dragStartHandler, draggableElemInfo]\n  );\n\n  const dragMove = useCallback(\n    (ev: MouseEvent | TouchEvent) => {\n      const { clientX, clientY, target } = ev instanceof TouchEvent ? ev.touches[0] : ev;\n      const touchShifteCoords = [40, 20];\n      if (ev instanceof TouchEvent) ev.preventDefault();\n\n      const bellowElem = getBellowElement(target as HTMLElement, clientX, clientY);\n      inDropArea.current = isDraggableElemInDropArea(bellowElem);\n      const currentAreaName = setCurrentArea(getBellowElemDataAttr(bellowElem));\n\n      if (currentAreaName !== debounce.current) {\n        debounce.current = currentAreaName;\n        currentArea.current = currentAreaName;\n        dragMoveHandler({\n          from: draggableElemInfo.from,\n          currentArea: currentArea.current as 'out-answersArea' | 'answersArea',\n        });\n      }\n\n      setTranslateCoords(prevState => ({\n        ...prevState,\n        x:\n          ev instanceof TouchEvent\n            ? clientX - shiftCoords.initialX - touchShifteCoords[0]\n            : clientX - shiftCoords.initialX - shiftCoords.shiftX,\n        y:\n          ev instanceof TouchEvent\n            ? clientY - shiftCoords.initialY - touchShifteCoords[1]\n            : clientY - shiftCoords.initialY - shiftCoords.shiftY,\n      }));\n      if (bellowElem) bellowElem.ondragstart = () => false;\n    },\n    [\n      dragMoveHandler,\n      draggableElemInfo.from,\n      getBellowElement,\n      isDraggableElemInDropArea,\n      setCurrentArea,\n      shiftCoords.initialX,\n      shiftCoords.initialY,\n      shiftCoords.shiftX,\n      shiftCoords.shiftY,\n    ]\n  );\n\n  const dragEnd = useCallback(\n    (ev: MouseEvent | TouchEvent) => {\n      const { clientX, clientY, target } = ev instanceof TouchEvent ? ev.changedTouches[0] : ev;\n\n      debounce.current = null;\n      const bellowElement = getBellowElement(target as HTMLElement, clientX, clientY);\n      inDropArea.current = isDraggableElemInDropArea(bellowElement);\n      const currentAreaName = setCurrentArea(getBellowElemDataAttr(bellowElement));\n\n      setDragStart(false);\n      setTranslateCoords(INITIAL_TRANSLATE_COORDS);\n      dragEndHandler({\n        from: draggableElemInfo.from,\n        originId: draggableElemInfo.originId,\n        dragId: draggableElemInfo.wordId,\n        currentArea: currentAreaName as 'answersArea' | 'waitingArea' | 'waitingAnchor',\n        anchorId: bellowElement\n          ? bellowElement.dataset.id || bellowElement.dataset.id === '0'\n            ? Number(bellowElement.dataset.id)\n            : null\n          : null,\n      });\n    },\n    [\n      dragEndHandler,\n      draggableElemInfo.from,\n      draggableElemInfo.originId,\n      draggableElemInfo.wordId,\n      getBellowElement,\n      isDraggableElemInDropArea,\n      setCurrentArea,\n    ]\n  );\n\n  useEffect(() => {\n    if (isDragStart && !isBlockAnimaton) {\n      window.addEventListener('mousemove', dragMove);\n      window.addEventListener('mouseup', dragEnd);\n      window.addEventListener('touchmove', dragMove, false);\n      window.addEventListener('touchend', dragEnd);\n    } else {\n      window.removeEventListener('mousemove', dragMove);\n      window.removeEventListener('mouseup', dragEnd);\n      window.removeEventListener('touchmove', dragMove);\n      window.removeEventListener('touchend', dragEnd);\n    }\n\n    return () => {\n      window.removeEventListener('mousemove', dragMove);\n      window.removeEventListener('mouseup', dragEnd);\n      window.removeEventListener('touchmove', dragMove);\n      window.removeEventListener('touchend', dragEnd);\n    };\n  }, [dragEnd, dragMove, isBlockAnimaton, isDragStart]);\n\n  const style = useMemo(\n    () => ({\n      willChange: 'transform',\n      transform: isDragStart\n        ? `translate(\n      ${translateCoords.x + originCoords.x}px, \n      ${translateCoords.y + originCoords.y}px)`\n        : `translate(${originCoords.x}px, ${originCoords.y}px)`,\n      transition: isDragStart || isTransitioned ? '' : `transform ${TRANSITION_TIME}ms ease`,\n      zIndex: isDragStart && 999,\n      position: isDragStart && 'absolute',\n      background: isDragStart && '#e9e8e8',\n    }),\n    [isDragStart, isTransitioned, originCoords.x, originCoords.y, translateCoords.x, translateCoords.y]\n  );\n\n  return <Fragment>{makeDraggableElement()}</Fragment>;\n};\n\nexport default React.memo(Draggable);\n","import styled from 'styled-components';\nimport { IStyledAnchorProps } from './Anchor.types';\nconst preparedColor = 'rgba(224, 224, 224, 0.452)';\nconst showColor = '#ececec';\n\nconst StyledAnchor = styled.li<IStyledAnchorProps>`\n  will-change: background-color;\n  transition: opacity 200ms ease, background-color 200ms ease;\n  opacity: 1;\n  width: 70px;\n  height: 30px;\n  border-radius: 13px;\n  display: inline-block;\n  background: ${props => !props.isHidden && showColor};\n  background: ${props => props.isPrepared && preparedColor};\n  box-shadow: ${props => !props.isHidden && 'inset 0px 8px 4px -6px rgba(0, 0, 0, 0.25)'};\n`;\n\nexport { StyledAnchor };\n","import React from 'react';\nimport { StyledAnchor } from './Anchor.styles';\nimport { IAnchorProps } from './Anchor.types';\nconst Anchor = ({ children, isHidden, isPrepared, isDataAttr, id }: IAnchorProps) => {\n  return (\n    <StyledAnchor\n      isHidden={!!isHidden}\n      isPrepared={!!isPrepared}\n      data-anchor={isDataAttr ? 'waitingAnchor' : 'answerAnchor'}\n      data-id={isHidden ? null : id}\n    >\n      {children}\n    </StyledAnchor>\n  );\n};\n\nexport default React.memo(Anchor);\n","import styled from 'styled-components';\n\nconst StyledDropArea = styled.div`\n  display: flex;\n  flex-flow: row wrap;\n  max-width: 470px;\n\n  &[data-dropname='waitingArea'] {\n    gap: 10px;\n    padding: 0;\n    margin: 0;\n  }\n`;\n\nconst Wrapper = styled.div`\n  display: flex;\n  flex-flow: row wrap;\n  flex-grow: 1;\n  gap: 10px;\n  border-top: 2px solid #cecccc;\n  padding: 10px 0px;\n  margin: 0;\n  list-style-type: none;\n\n  &:last-child {\n    justify-content: flex-start;\n    border-bottom: 2px solid #cecccc;\n  }\n`;\n\nexport { Wrapper, StyledDropArea };\n","import React, { forwardRef } from 'react';\nimport AnswerWord from '../../atoms/AnswerWord/AnswerWord';\nimport { IDropAreaProps } from './DropArea.types';\nimport Draggable from '../../libs/Draggable/Draggable';\nimport Anchor from '../../atoms/Anchor/Anchor';\nimport { IWord } from '../../atoms/AnswerWord/AnswerWord.types';\nimport { IAnchor } from '../../atoms/Anchor/Anchor.types';\nimport { StyledDropArea, Wrapper } from './DropArea.styles';\n\nconst DropArea = forwardRef<any, IDropAreaProps>(\n  (\n    {\n      areaName,\n      anchors,\n      words,\n      originCoords,\n      dragStartHandler,\n      dragMoveHandler,\n      dragEndHandler,\n      isTransitioned,\n      isBlockAnimaton,\n    },\n    ref\n  ) => {\n    const preparedWords: { [key: string]: IWord } = words.reduce(\n      (acc, item) => ({ ...acc, [item.wordId]: { ...item } }),\n      {}\n    );\n    const createWord = (anchor: IAnchor, isDataAttribute: boolean = false) => (\n      <Anchor\n        key={anchor.anchorId}\n        isHidden={anchor.isHidden}\n        isPrepared={anchor.isPrepared}\n        isDataAttr={isDataAttribute}\n        id={anchor.anchorId}\n      >\n        {preparedWords[anchor.anchorId] && (\n          <Draggable\n            draggableElemInfo={{ ...preparedWords[anchor.anchorId] }}\n            isTransitioned={isTransitioned}\n            originCoords={originCoords[anchor.anchorId] ?? { x: 0, y: 0 }}\n            dragStartHandler={dragStartHandler}\n            dragMoveHandler={dragMoveHandler}\n            dragEndHandler={dragEndHandler}\n            isBlockAnimaton={isBlockAnimaton}\n          >\n            <AnswerWord content={preparedWords[anchor.anchorId].text} key={preparedWords[anchor.anchorId].wordId} />\n          </Draggable>\n        )}\n      </Anchor>\n    );\n\n    // [words] => [[words],[words],[wrods]...]\n    const getPreparedAnchors = () =>\n      [...Array(Math.ceil(anchors.length / 6)).keys()].map(row => anchors.slice(row * 6, (row + 1) * 6));\n\n    const createAnchors = () =>\n      getPreparedAnchors().map((anchorWrapper, rowId) => (\n        <Wrapper key={rowId}>{anchorWrapper.map(anchor => createWord(anchor))}</Wrapper>\n      ));\n\n    return areaName === 'answersArea' ? (\n      <StyledDropArea data-dropname={areaName} ref={ref}>\n        {createAnchors()}\n      </StyledDropArea>\n    ) : (\n      <StyledDropArea data-dropname={areaName} ref={ref}>\n        {anchors.map(anchor => createWord(anchor, true))}\n      </StyledDropArea>\n    );\n  }\n);\n\nexport default DropArea;\n","import styled from 'styled-components';\n\nconst StyledQuiz = styled.div`\n  max-width: 472px;\n  margin: 0 auto;\n  display: flex;\n  flex-flow: column nowrap;\n  align-items: center;\n  padding: 0px 0px 30px 0;\n`;\nconst QuizInfo = styled.div`\n  margin-bottom: 20px;\n  display: flex;\n`;\nconst QuizAnswersWrapper = styled.div`\n  margin-bottom: 50px;\n`;\n\nconst QuizWaitingWrapper = styled.div`\n  margin-bottom: 25px;\n`;\n\nconst QuizButtonWrapper = styled.div`\n  max-width: 320px;\n  width: 100%;\n`;\nexport { StyledQuiz, QuizInfo, QuizAnswersWrapper, QuizWaitingWrapper, QuizButtonWrapper };\n","import React, { RefObject, useCallback, useEffect, useRef, useState } from 'react';\nimport Avatar from '../../atoms/Avatar/Avatar';\nimport Button from '../../atoms/Button/Button';\nimport SentenceWord from '../../atoms/SentenceWord/SentenceWord';\nimport Title from '../../atoms/Title/Title';\nimport Sentence from '../../molecules/Sentence/Sentence';\nimport { INITIAL_DRAGGABLE_ID, TRANSITION_TIME } from '../../settings/constants';\nimport { IAnchor } from '../../atoms/Anchor/Anchor.types';\nimport { IWord } from '../../atoms/AnswerWord/AnswerWord.types';\nimport {\n  calcOriginCoords,\n  getAnchorsDomCoords,\n  getConvertedWords,\n  getCorrectAnchors,\n  getCorrectWords,\n  getIdBeforeDraggableElem,\n  getShiftedWords,\n  getUpdatedAnswersAnchors,\n  getAnchorsDomList,\n  getCorrectText,\n  getQuestionText,\n} from './Quiz.helpers';\nimport Message from '../../atoms/Message/Message';\nimport {\n  IOriginCoords,\n  IQuizProps,\n  TDragEndHandler,\n  TDraggableId,\n  TDragMoveHandler,\n  TDragStartHandler,\n} from './Quiz.types';\nimport DropArea from '../../molecules/DropArea/DropArea';\nimport { QuizAnswersWrapper, QuizButtonWrapper, QuizInfo, QuizWaitingWrapper, StyledQuiz } from './Quiz.styles';\nconst Quiz = ({ quizId }: IQuizProps) => {\n  // result-info----------------------------------------------------------\n  const [resultMessage, setResultMessage] = useState<string | null>(null);\n  const [isError, setError] = useState<boolean | null>(null);\n\n  // animation-data------------------------------------------------------\n  const [isBlockAnimaton, setBlockAnimation] = useState(false);\n  const [dragEndEvent, setDragEndEvent] = useState<string>('');\n  const waitingRef = useRef() as RefObject<HTMLUListElement>;\n  const answersRef = useRef() as RefObject<HTMLDivElement>;\n  const isTransitioned = useRef(false);\n  const [draggableId, setDraggableId] = useState<TDraggableId>(INITIAL_DRAGGABLE_ID);\n\n  // origin-coords-------------------------------------------------------\n  const [waitingOriginCoords, setWaitingOriginCoords] = useState<IOriginCoords>({});\n  const [answersOriginCoords, setAnswersOriginCoords] = useState<IOriginCoords>({});\n  // words---------------------------------------------------------------\n  const [waitingWords, setWaitingWords] = useState<IWord[]>(getCorrectWords('ru', 'answers', quizId));\n  const [answersWords, setAnswersWords] = useState<IWord[]>([]);\n  // anchors-------------------------------------------------------------\n  const [answersAnchors, setAnswersAnchors] = useState(getCorrectAnchors('ru', 'answers', quizId));\n\n  // HELPER FUNCTIONS---------------------------------------------\n  const getNewOriginCoords = useCallback(\n    (target: 'waiting' | 'answers', dragId: number): IOriginCoords => {\n      const prevOriginCoords = target === 'waiting' ? waitingOriginCoords : answersOriginCoords;\n      const root = target === 'waiting' ? (waitingRef.current as HTMLElement) : (answersRef.current as HTMLElement);\n      const idBeforeDraggableElem = getIdBeforeDraggableElem(\n        {\n          wordsList: target === 'waiting' ? waitingWords : answersWords,\n          wordsArea: target,\n        },\n        getConvertedWords(target === 'waiting' ? waitingWords : answersWords)[dragId],\n        'take'\n      );\n      const calculatedOriginCoords = calcOriginCoords(root, idBeforeDraggableElem);\n      return {\n        ...prevOriginCoords,\n        ...calculatedOriginCoords,\n      };\n    },\n    [answersOriginCoords, answersWords, waitingOriginCoords, waitingWords]\n  );\n\n  const getAnswerPreparedAnchor = useCallback(\n    () => [...answersAnchors].reverse().find(anchor => anchor.isPrepared) as IAnchor,\n    [answersAnchors]\n  );\n\n  const getEmptyAnswerAnchor = (anchors: IAnchor[]) => anchors.find(anchor => anchor.answerId === null) as IAnchor;\n\n  const isTargetWaitingAnchorBusy = (currentArea: string, anchorId: number) =>\n    currentArea === 'waitingAnchor' && getAnchorsDomList(waitingRef.current as HTMLUListElement)[anchorId].children[0];\n\n  const resetOriginCoords = (time: number = 0) => {\n    setAnswersOriginCoords({});\n    setWaitingOriginCoords({});\n    setTimeout(() => setBlockAnimation(false), time);\n  };\n\n  const translateDragElemFromPending = useCallback(\n    (params: { anchorId: number; dragId: number }) => {\n      const { anchorId, dragId } = params;\n      const targetAnchorCoords = getAnchorsDomCoords(answersRef.current as HTMLElement)[anchorId];\n      const draggableElemCoords = getAnchorsDomCoords(waitingRef.current as HTMLElement)[dragId];\n      setWaitingOriginCoords({\n        ...waitingOriginCoords,\n        [dragId]: {\n          x: targetAnchorCoords.x - draggableElemCoords.x,\n          y: targetAnchorCoords.y - draggableElemCoords.y,\n        },\n      });\n    },\n    [waitingOriginCoords]\n  );\n\n  const translateDragElemFromAnswers = useCallback(\n    (\n      params: { dragId: number; anchorId: number },\n      anchorsRoot: HTMLDivElement | HTMLUListElement = waitingRef.current as HTMLUListElement\n    ) => {\n      const { dragId, anchorId } = params;\n      const draggableElemCoords = getAnchorsDomCoords(answersRef.current as HTMLElement)[dragId];\n      const targetAnchorCoords = getAnchorsDomCoords(anchorsRoot)[anchorId];\n      setAnswersOriginCoords({\n        ...answersOriginCoords,\n        [dragId]: {\n          x: targetAnchorCoords.x - draggableElemCoords.x,\n          y: targetAnchorCoords.y - draggableElemCoords.y,\n        },\n      });\n    },\n    [answersOriginCoords]\n  );\n\n  const translateWaitingWords = useCallback(\n    (dragId: number) => {\n      const idBeforeDraggableElem = getIdBeforeDraggableElem(\n        { wordsList: waitingWords, wordsArea: 'waiting' },\n        getConvertedWords(answersWords)[dragId],\n        'put'\n      );\n\n      setWaitingOriginCoords({\n        ...waitingOriginCoords,\n        ...calcOriginCoords(waitingRef.current as HTMLElement, idBeforeDraggableElem, { direction: 'right' }),\n      });\n    },\n    [answersWords, waitingOriginCoords, waitingWords]\n  );\n\n  // HANDLER FUNCTIONS---------------------------------------------\n  const checkAnswerHandler = useCallback(() => {\n    const correctText = getCorrectText(quizId);\n    const answersText = answersWords.map(word => word.text).join(' ');\n\n    if (correctText.localeCompare(answersText) === 0) {\n      setResultMessage('is complete!!!');\n    } else {\n      setError(true);\n      setResultMessage('something wrong');\n    }\n  }, [answersWords, quizId]);\n\n  const dragStartHandler: TDragStartHandler = useCallback(\n    ({ dragId, from }) => {\n      isTransitioned.current = false; // enable transition\n      setResultMessage(null);\n      setError(null);\n      if (from === 'waiting') {\n        setWaitingOriginCoords(getNewOriginCoords('waiting', dragId));\n      } else {\n        setAnswersAnchors(getUpdatedAnswersAnchors(answersAnchors, 'prepareLast'));\n        setAnswersOriginCoords(getNewOriginCoords('answers', dragId));\n      }\n    },\n    [answersAnchors, getNewOriginCoords]\n  );\n\n  const dragMoveHandler: TDragMoveHandler = useCallback(\n    ({ from, currentArea }) => {\n      if (from === 'waiting') {\n        if (currentArea === 'answersArea') setAnswersAnchors(getUpdatedAnswersAnchors(answersAnchors, 'prepare'));\n        if (currentArea === 'out-answersArea') {\n          setAnswersAnchors(getUpdatedAnswersAnchors(answersAnchors, 'disprepare'));\n        }\n      }\n    },\n    [answersAnchors]\n  );\n\n  const dragEndHandler: TDragEndHandler = useCallback(\n    ({ dragId, from, currentArea, originId, anchorId }) => {\n      setBlockAnimation(true); // disable handlers\n      if (from === 'waiting') {\n        if (currentArea === 'answersArea') {\n          // ANIMATION-----------------------------------------\n          translateDragElemFromPending({ anchorId: getEmptyAnswerAnchor(answersAnchors).anchorId, dragId });\n          setDraggableId({ originId, wordId: dragId });\n          setDragEndEvent('waiting-answers');\n        } else {\n          resetOriginCoords(100);\n        }\n      }\n\n      if (from === 'answers') {\n        const correctCurrentArea = isTargetWaitingAnchorBusy(currentArea, anchorId as number)\n          ? 'waitingArea'\n          : currentArea;\n        if (correctCurrentArea === 'waitingArea') {\n          // translate drag elem to pending\n          translateDragElemFromAnswers({ dragId, anchorId: originId });\n\n          // translate pending words\n          const idBeforeDraggableElem = getIdBeforeDraggableElem(\n            { wordsList: waitingWords, wordsArea: 'waiting' },\n            getConvertedWords(answersWords)[dragId],\n            'put'\n          );\n          setWaitingOriginCoords({\n            ...waitingOriginCoords,\n            ...calcOriginCoords(waitingRef.current as HTMLElement, idBeforeDraggableElem, { direction: 'right' }),\n          });\n\n          //UPDATE STATE----------------------------------\n          setDraggableId({ originId, wordId: dragId });\n          setDragEndEvent('answers-waiting');\n        } else if (correctCurrentArea === 'waitingAnchor') {\n          // TRANSLATE TO THE WRONG ANCHOR-----------------------------\n          translateDragElemFromAnswers({ dragId, anchorId: anchorId as number });\n\n          // TRANSLATE TO THE ORIGIN ANCHOR----------------------------\n          setDraggableId({ wordId: dragId, originId: originId });\n          setDragEndEvent('answers-wrong-waiting');\n        } else {\n          setBlockAnimation(true); // disable handlers\n\n          translateDragElemFromAnswers(\n            { dragId, anchorId: getAnswerPreparedAnchor().anchorId },\n            answersRef.current as HTMLDivElement\n          );\n          setDraggableId({ originId, wordId: dragId });\n          setDragEndEvent('answers-answers');\n        }\n      }\n    },\n    [\n      translateDragElemFromPending,\n      answersAnchors,\n      translateDragElemFromAnswers,\n      waitingWords,\n      answersWords,\n      waitingOriginCoords,\n      getAnswerPreparedAnchor,\n    ]\n  );\n\n  useEffect(() => {\n    switch (dragEndEvent) {\n      case 'waiting-answers': {\n        setTimeout(() => {\n          setDragEndEvent('');\n          isTransitioned.current = true; // off transition\n\n          // show last anchor in answers area\n          setAnswersAnchors(getUpdatedAnswersAnchors(answersAnchors, 'setBusy'));\n\n          // shift words in waiting area\n          const idBeforeDraggableElem = getIdBeforeDraggableElem(\n            { wordsList: waitingWords, wordsArea: 'waiting' },\n            getConvertedWords(waitingWords)[draggableId.wordId],\n            'take'\n          );\n\n          setWaitingWords(\n            getShiftedWords(waitingWords, draggableId.wordId, idBeforeDraggableElem, {\n              elementAction: 'remove',\n              directionShift: 'left',\n            })\n          );\n\n          // add word to end of answers area\n          const targetWord = getConvertedWords(waitingWords)[draggableId.wordId];\n          setAnswersWords([\n            ...answersWords,\n            { ...targetWord, wordId: getEmptyAnswerAnchor(answersAnchors).anchorId, from: 'answers' },\n          ]);\n          resetOriginCoords(100);\n        }, TRANSITION_TIME);\n        break;\n      }\n      case 'answers-waiting': {\n        setTimeout(() => {\n          setDragEndEvent('');\n          isTransitioned.current = true; // off transition\n\n          // shift waiting words\n          const idBeforeDraggableElem = getIdBeforeDraggableElem(\n            { wordsList: waitingWords, wordsArea: 'waiting' },\n            getConvertedWords(answersWords)[draggableId.wordId],\n            'put'\n          );\n          const shiftedwaitingWords = getShiftedWords(waitingWords, draggableId.originId, idBeforeDraggableElem, {\n            elementAction: 'add',\n            directionShift: 'right',\n          });\n          const convertedWords = getConvertedWords(shiftedwaitingWords);\n          convertedWords[draggableId.originId] = {\n            ...getConvertedWords(answersWords)[draggableId.wordId],\n            from: 'waiting',\n            wordId: draggableId.originId,\n          };\n          setWaitingWords(Object.values(convertedWords));\n\n          // shift answers words\n          const idBeforeAnswers = getIdBeforeDraggableElem(\n            { wordsList: answersWords, wordsArea: 'answers' },\n            getConvertedWords(answersWords)[draggableId.wordId],\n            'take'\n          );\n          const shiftedAnswersWords = getShiftedWords(answersWords, draggableId.wordId, idBeforeAnswers, {\n            elementAction: 'remove',\n            directionShift: 'left',\n          });\n          setAnswersWords(shiftedAnswersWords);\n\n          // hide last anchor in answers area\n          setAnswersAnchors(getUpdatedAnswersAnchors(answersAnchors, 'delBusy'));\n\n          resetOriginCoords(100);\n        }, TRANSITION_TIME);\n        break;\n      }\n      case 'answers-wrong-waiting': {\n        setTimeout(() => {\n          setDragEndEvent('');\n          translateWaitingWords(draggableId.wordId);\n          translateDragElemFromAnswers({ dragId: draggableId.wordId, anchorId: draggableId.originId });\n\n          // UPDATE STATE---------------------------------------------\n          setDragEndEvent('answers-waiting');\n        }, TRANSITION_TIME + 500);\n        break;\n      }\n      case 'answers-answers': {\n        setTimeout(() => {\n          setDragEndEvent('');\n          isTransitioned.current = true; // off transition\n\n          const targetWord = getConvertedWords(answersWords)[draggableId.wordId];\n          const idBeforeDraggableElem = getIdBeforeDraggableElem(\n            {\n              wordsList: answersWords,\n              wordsArea: 'answers',\n            },\n            targetWord,\n            'take'\n          );\n          const shiftedAnswerWords = getShiftedWords(answersWords, draggableId.wordId, idBeforeDraggableElem, {\n            elementAction: 'remove',\n            directionShift: 'left',\n          });\n          shiftedAnswerWords.push({ ...targetWord, wordId: shiftedAnswerWords.length });\n\n          setAnswersWords(shiftedAnswerWords);\n          setAnswersAnchors(\n            answersAnchors.map(anchor => (anchor.isPrepared ? { ...anchor, isPrepared: false } : anchor))\n          );\n          resetOriginCoords(100);\n        }, TRANSITION_TIME);\n        break;\n      }\n    }\n  }, [\n    answersAnchors,\n    answersWords,\n    dragEndEvent,\n    draggableId,\n    waitingWords,\n    translateDragElemFromAnswers,\n    translateWaitingWords,\n  ]);\n\n  return (\n    <StyledQuiz>\n      <Title content=\"Translate this sentence\" />\n      <QuizInfo>\n        <Avatar />\n        <Sentence>\n          {getQuestionText(quizId)\n            .split(' ')\n            .map((word, index) => (\n              <li key={index}>\n                <SentenceWord content={word} />\n              </li>\n            ))}\n        </Sentence>\n      </QuizInfo>\n      <QuizAnswersWrapper className=\"answers-wrapper\">\n        <DropArea\n          dragStartHandler={dragStartHandler}\n          dragMoveHandler={dragMoveHandler}\n          dragEndHandler={dragEndHandler}\n          originCoords={answersOriginCoords}\n          areaName=\"answersArea\"\n          words={answersWords}\n          anchors={answersAnchors}\n          isTransitioned={isTransitioned.current}\n          isBlockAnimaton={isBlockAnimaton}\n          ref={answersRef}\n        />\n      </QuizAnswersWrapper>\n      <QuizWaitingWrapper className=\"waiting-wrapper\">\n        <DropArea\n          dragStartHandler={dragStartHandler}\n          dragMoveHandler={dragMoveHandler}\n          dragEndHandler={dragEndHandler}\n          originCoords={waitingOriginCoords}\n          areaName=\"waitingArea\"\n          words={waitingWords}\n          anchors={getCorrectAnchors('ru', 'correct', quizId)}\n          isTransitioned={isTransitioned.current}\n          isBlockAnimaton={isBlockAnimaton}\n          ref={waitingRef}\n        />\n      </QuizWaitingWrapper>\n      <Message content={resultMessage} isError={isError} />\n      <QuizButtonWrapper className=\"btn-wrapper\">\n        <Button isMove={!!resultMessage} onclickHandler={isBlockAnimaton ? null : checkAnswerHandler} content=\"click\" />\n      </QuizButtonWrapper>\n    </StyledQuiz>\n  );\n};\n\nexport default Quiz;\n","import React from 'react';\nimport StyledApp from './App.styles';\nimport Quiz from './pages/Quiz/Quiz';\nconst App = () => {\n  return (\n    <StyledApp className=\"App\">\n      <Quiz quizId={'q1'} />\n    </StyledApp>\n  );\n};\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","export default __webpack_public_path__ + \"static/media/Roboto-Regular.96533686.woff\";","import { createGlobalStyle } from 'styled-components';\nimport { normalize } from 'styled-normalize';\nimport RobotoURLwoff from './Roboto/Roboto-Regular.woff';\nexport default createGlobalStyle`\n${normalize}\n@font-face {\n    font-family: 'Roboto';\n    src: url(${RobotoURLwoff}) format('woff');\n    font-weight: ${400};\n    font-style: normal;\n  }\n`;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\nimport GlobalStyles from './settings/fonts/fonts';\nReactDOM.render(\n  <React.StrictMode>\n    <GlobalStyles />\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\nreportWebVitals();\n"],"sourceRoot":""}